# # test_example.py


# # Тестируемый код
# # ---------->

# def one_more(x):
#     return x + 1

# # # Вот теперь ясно: автор функции забыл про сортировку.
# # def get_sort_list(string):
# #     new_list = string.split(',')
# #     return new_list

# # Исправим функцию get_sort_list(): отсортируем список.
# def get_sort_list(string):
#     # Сортировка и пробел после запятой в аргументе.
#     new_list = sorted(string.split(', '))  
#     return new_list




# # Тесты
# # ---------->

# def test_correct():
#     print('Правильный тест')  # Новая строка.
#     assert one_more(4) == 5


# def test_fail():
#     print('Неправильный тест')  # Новая строка.
#     assert one_more(3) == 5


# # Опечатка автора теста в именах Миша/Маша
# # def test_sort():
# #     """Тестируем функцию get_sort_list()."""
# #     result = get_sort_list('Яша, Саша, Маша, Даша')
# #     assert result == ['Даша', 'Миша', 'Саша', 'Яша']


# def test_sort():
#     """Тестируем функцию get_sort_list()."""
#     result = get_sort_list('Яша, Саша, Маша, Даша')
#     assert result  == ['Даша', 'Маша', 'Саша', 'Яша']  # 'Маша', а не 'Миша'.


# def test_type():
#     """Тестируем тип данных, возвращаемых из get_sort_list()."""
#     result = get_sort_list('Яша, Саша, Маша, Даша')
#     # Провальный тест:
#     # ожидаем число, но вернётся список.
#     assert isinstance(result, int)




# # Список команд терминала
# # ---------->

# # pytest test_example.py -qq --lf

# # --lf (--last-failed)
# # будут выполнены только те тесты, которые провалились в прошлый раз

# # --ff (--failed-first)
# # сначала будут выполнены провалившиеся тесты, а после них — все остальные

# # --nf (--new-first)
# # «старые» тесты будут выполняться в порядке «сначала новые, потом старые»,
# # в зависимости от даты модификации файлов с тестами

# # -x (--exitfirst)
# # Тестирование в режиме «до первого упавшего теста»

# # --maxfail=N (--maxfail=3)
# # Выполнение тестов можно останавливать не только после первого падения,
# # но и после провала любого другого количества тестов.
# # Количество можно указать в ключе

# # --sw (--stepwise)
# # Пошаговое выполнение тестов, при котором можно «фиксить» проблемы по очереди
# # у режима stepwise есть полезная особенность: если не удаётся решить
# # проблему с каким-то падающим тестом — его можно пропустить и перейти к следующему.
# # Делается это при помощи ключа --stepwise-skip

# # Перехват потока вывода можно отключить: для этого тесты запускают с
# # ключом -s (другой вариант — --capture=no).
# # Выполните команду pytest -s -k "correct or fail"

# # При запуске тестов с ключом -s данные из print() выводятся независимо от того,
# # успешно прошёл тест или провалился.

# # pytest -rP -k "correct or fail"
# # Ещё один вариант — вывести дополнительную информацию после всех тестов.
# # Делается это при помощи ключа -rP, в котором буква r обозначает вывод
# # дополнительной информации (show extra test summary info), а заглавная
# # буква P указывает на успешно пройденные тесты с выводом
# # данных (Passed with output).

# # Когда нужно вывести в терминал результат работы print() из успешно
# # пройденных тестов, используйте любой понравившийся вариант:
# # pytest -s
# # pytest -s -v
# # pytest -rP





# Работа с маркерами.
# Маркеры pytest: пропуск тестов, ожидаемое падение и параметризация.
# ---------->

# # test_example.py
# import pytest


# # Тестируемый код
# # ---------->

# def one_more(x):
#     return x + 1


# def get_sort_list(str):
#     new_list = sorted(str.split(', '))
#     return new_list





# # Тесты
# # ---------->

# def test_correct():
#     assert one_more(4) == 5


# @pytest.mark.skip(reason='Что-то не работает')  # Маркер.
# def test_fail():
#     assert one_more(3) == 5


# def test_sort():
#     """Тестируем функцию get_sort_list()."""    
#     result = get_sort_list('Яша, Саша, Маша, Даша')
#     assert result == ['Даша', 'Маша', 'Саша', 'Яша']


# def test_type():
#     """Тестируем тип данных, возвращаемых из get_sort_list()."""
#     # Провальный тест:
#     # ожидаем число, но вернётся список.
#     result = get_sort_list('Яша, Саша, Маша, Даша')
#     assert isinstance(result, int)





# Параметризация тестов
# ---------->

# test_example.py
import pytest


# # Тестируемый код
# # ---------->

def one_more(x):
    return x + 1


def get_sort_list(str):
    new_list = sorted(str.split(', '))
    return new_list





# # Тесты
# # ---------->

@pytest.mark.parametrize(
    'input_arg, expected_result',  # Названия аргументов, передаваемых в тест.
    [(4, 5), (3, 5)]  # Список кортежей со значениями аргументов.
)
def test_one_more(input_arg, expected_result):  # Те же параметры, что и в декораторе.
    assert one_more(input_arg) == expected_result


# # Также можно передать параметры списком
# @pytest.mark.parametrize(
#     ['input_arg', 'expected_result'],  # Названия аргументов можно передать списком.
#     [(4, 5), (3, 5)]
# )


def test_sort():
    """Тестируем функцию get_sort_list()."""    
    result = get_sort_list('Яша, Саша, Маша, Даша')
    assert result == ['Даша', 'Маша', 'Саша', 'Яша']


def test_type():
    """Тестируем тип данных, возвращаемых из get_sort_list()."""
    # Провальный тест:
    # ожидаем число, но вернётся список.
    result = get_sort_list('Яша, Саша, Маша, Даша')
    assert isinstance(result, int)





# # Задание
# # Обязательно запустите код: по отчёту будет понятна логика
# # выполнения тестов; заодно станет понятен правильный ответ.
# # Сколько раз будет выполнен тест test_cartesian_product()?
# # Ответ: 4 раза (столько, сколько сочетаний аргументов).
# # ---------->

# # # Тестируемый код
# # # ---------->
# def cartesian_product(a, b):
#     return a * b

# # # # Тесты
# # # # ---------->
# @pytest.mark.parametrize('x', [1, 2])
# @pytest.mark.parametrize('y', ['one', 'two'])
# def test_cartesian_product(x, y):
#     assert cartesian_product(x, y) is not None

# # Задание выполнено
# # ----------<
